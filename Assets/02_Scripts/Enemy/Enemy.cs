using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class Enemy : EnemyBase
{
    Animator anim;
    enum State
    {
        Idle,
        Move,
        Battle,
        Die
    }
    State state = State.Idle;

    NavMeshAgent agent;
    [Header("AI")]
    public Transform target;
    private float distance_IdleToMove = 10f; // Idle에서 Move로 전환하는 거리 임계값
    private float distance_MoveToBattle = 4f; // Move에서 Battle로 전환하는 거리 임계값

    readonly int IsMoveHash = Animator.StringToHash("isMove");
    readonly int IsBattleInHash = Animator.StringToHash("isBattleIn");
    readonly int AttackPatternHash = Animator.StringToHash("AttackPattern");
    readonly int IsDieHash = Animator.StringToHash("isDie");

    private bool isInteract = false;
    // ray의 길이
    [SerializeField]
    private float _maxDistance = 3.0f;

    // ray의 색상
    [SerializeField]
    private Color _rayColor = Color.red;

    void OnDrawGizmos()
    {
        Gizmos.color = _rayColor;

        // 함수 파라미터 : 현재 위치, Box의 절반 사이즈, Ray의 방향, RaycastHit 결과, Box의 회전값, BoxCast를 진행할 거리
        if (true == Physics.BoxCast(transform.position, transform.lossyScale / 2.0f, transform.forward, out RaycastHit hit, transform.rotation, _maxDistance))
        {
            // Hit된 지점까지 ray를 그려준다.
            Gizmos.DrawRay(transform.position, transform.forward * hit.distance);

            // Hit된 지점에 박스를 그려준다.
            Gizmos.DrawWireCube(transform.position + transform.forward * hit.distance, transform.lossyScale);
        }
        else
        {
            // Hit가 되지 않았으면 최대 검출 거리로 ray를 그려준다.
            Gizmos.DrawRay(transform.position, transform.forward * _maxDistance);
        }
    }
    protected override void Awake()
    {
        base.Awake();
        agent = GetComponent<NavMeshAgent>();
        anim = GetComponent<Animator>();    
    }
    private void Start()
    {
        if(target == null)
        {
            Debug.Log("타겟이 없음!");
        }
    }

    private void Update()
    {
        if (target == null)  //플레이어가 사라지면 Idle로 변경
        {
            EnterIdle();
        }

        switch (state)
        {
            case State.Idle:    Idle();
                break;
            case State.Move:    Move();
                break; 
            case State.Battle:  Battle();
                break;
            case State.Die:     EnemyDie();
                break;
        }

    }

    void Idle()
    {
        // 플레이어나 추적 대상의 위치와 현재 위치 사이의 거리를 계산
        float distanceToTarget = Vector3.Distance(transform.position, target.position);

        // 거리가 일정 값 이하면 Move 상태로 전환
        if (distanceToTarget <= distance_IdleToMove)
        {
            EnterMove();
            Debug.Log("Switching to Move state.");
        }
    }

    void Move()
    {
        float distanceToTarget = Vector3.Distance(transform.position, target.position);
        agent.SetDestination(target.position);
        agent.stoppingDistance = 2;                     //enemy가 멈추는 거리
        if (distanceToTarget <= distance_MoveToBattle)  //공격가능 거리 안에 들어오면 Battle로 변경
        {
            EnterBattle(); // Battle 상태로 전환 시 추가적인 동작 수행
        }
    }

    void Battle()
    {
        float distanceToTarget = Vector3.Distance(transform.position, target.position);
        LookAtPlayer();

        //Battle중에서의 상태 변경
        if (distanceToTarget > distance_MoveToBattle)  //플레이어가 멀어지면 Move로 변경
        {
            EnterMove();
        }
        RaycastHit hit;
        if (Physics.BoxCast(transform.position, transform.lossyScale / 2.0f, transform.forward, out hit, transform.rotation, _maxDistance))
        {
            if (hit.collider.CompareTag("Player"))
            {
                //앞에 플레이어가 있으니 공격 ㄱㄱ
            }
        }
        else
        {
            //EnterMove();
        }
    }
    
    //Battle에서 사용하는 플레이어를 바라보는 함수
    void LookAtPlayer()
    {
        Vector3 followPlayer = (target.position - transform.position).normalized;
        followPlayer.y = 0;
        Quaternion targetRotation = Quaternion.LookRotation(followPlayer);
        transform.rotation = targetRotation;
    }

    #region State 변경 함수
    private void EnterIdle()
    {
        state = State.Idle;

        anim.SetBool(IsMoveHash, false);
        anim.SetBool(IsBattleInHash, false);
        anim.SetInteger(AttackPatternHash, 0);  //콤보 0으로 초기화
        Debug.Log("Entering Idle state.");
    }

    private void EnterMove()
    {
        state = State.Move;

        anim.SetBool(IsMoveHash, true);
        Debug.Log("Entering Move state.");
    }

    private void EnterBattle()
    {
        state = State.Battle;

        anim.SetBool(IsMoveHash, false);
        Debug.Log("Entering Battle state.");
    }
    #endregion

    protected override void EnemyDie()
    {
        base.EnemyDie();
        isAttacking = false;
        isInteract = true;
        state = State.Die;
        anim.SetBool(IsDieHash, true);
    }
}
